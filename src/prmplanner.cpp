/*! @file
 *
 *  @brief A low dispersion PRM planner.
 *
 *  The idea of the LD-PRM is to capture the connectivity of the
 *  configuration space with fewer samples, which reduces the
 *  running time of the algorithm. Different to a simple PRM planner,
 *  the samples generated by the LD-PRM must fufil an important criterion
 *  in order to be included inside the roadmap. Samples are forbidden to
 *  be close to each other more than a predefined radius. This criterion
 *  creates an almost uniform distribution of samples which helps in
 *  narrow passageways.
 *  For more information, please see http://cdn.intechopen.com/pdfs/45913.pdf
 *
 *  @author arosspope
 *  @date 12-10-2017
*/
#include "prmplanner.h"

#include <math.h>
#include <random>
#include <thread>
#include <chrono>

PrmPlanner::PrmPlanner():
  graph_(Graph(PLANNER_DEF_DENSITY)), lmap_(LocalMap(PLANNER_DEF_MAP_SIZE, PLANNER_DEF_MAP_RES))
{
  nextVertexId_ = 0;
  reference_.x = 0;
  reference_.y = 0;
  density_ = PLANNER_DEF_DENSITY;
}

PrmPlanner::PrmPlanner(double mapSize, double mapRes, unsigned int density):
  graph_(Graph(density)), lmap_(LocalMap(mapSize, mapRes))
{
  nextVertexId_ = 0;
  reference_.x = 0;
  reference_.y = 0;
  density_ = density;
}

std::vector<TGlobalOrd> PrmPlanner::build(cv::Mat &cspace, TGlobalOrd start, TGlobalOrd goal)
{
  vertex vStart, vGoal;
  std::vector<TGlobalOrd> path;
  std::vector<vertex> vPath;

  //Check that both ordinates are accessible
  if(!ordinateAccessible(cspace, start) || !ordinateAccessible(cspace, goal)){
    return path;
  }

  //Perhaps there is an existing path already...
  path = query(cspace, start, goal);
  if(path.size() > 0){
    return path;
  }

  //It's important that the start/goal are embeded to at least one other
  //node in the network, otherwise there is a chance the start and goal
  //don't become connected as the map becomes denser with nodes
  vStart = findOrAdd(start);
  vGoal = findOrAdd(goal);
  embedNode(cspace, vStart, 1, true);
  embedNode(cspace, vGoal, 1, true);

  //Calculate seperation radius
  unsigned int numNodes = network_.size() + 200;
  double freeSpace = lmap_.freeConfigSpace(cspace);
  double r = (1.0/(double)numNodes)*std::sqrt((freeSpace*(numNodes - std::pow(numNodes, 0.5)))/M_PI);

  //Build 200 nodes at a time
  while(network_.size() < numNodes){
    TGlobalOrd randomOrd;
    //Generate random ords within the map space...
    std::default_random_engine generator(std::chrono::duration_cast<std::chrono::nanoseconds>
                                         (std::chrono::system_clock::now().time_since_epoch()).count());

    double mapSize = lmap_.getMapSize();
    std::uniform_real_distribution<double> xDist(reference_.x - (mapSize/2), reference_.x + (mapSize/2));
    std::uniform_real_distribution<double> yDist(reference_.y - (mapSize/2), reference_.y + (mapSize/2));

    //round to 1 decimal place
    randomOrd.x = std::round((xDist(generator) * 10.0))/10.0;
    randomOrd.y = std::round((yDist(generator) * 10.0))/10.0;

    if(existsAsVertex(randomOrd)){
      continue; //Already exists in graph, skip
    }

    if(!lmap_.isAccessible(cspace, lmap_.convertToPoint(reference_, randomOrd))){
      continue; //Is not accessible in the ogmap, skip
    }

    if(violatingSpace(randomOrd, r)){
      continue; //We want uniform distribution, skip
    }

    //Its passed all checks, add the ordinate to the graph!
    addOrdinate(randomOrd);
  }

  //Attempt to connect start and goal continously
  embedNode(cspace, vStart, density_, true);
  embedNode(cspace, vGoal, density_, true);
  joinNetwork(cspace, density_);

  return query(cspace, start, goal);
}

std::vector<TGlobalOrd> PrmPlanner::query(cv::Mat &cspace, TGlobalOrd start, TGlobalOrd goal){
  vertex vStart, vGoal;

  if(!lookup(start, vStart) || !lookup(goal, vGoal)){
    return std::vector<TGlobalOrd>();
  }

  //Assumes the path has already been found
  std::vector<vertex> vPath = graph_.shortestPath(vStart, vGoal);
  if(vPath.size() > 0){
    return optimisePath(cspace, toOrdPath(vPath));
  }

  return std::vector<TGlobalOrd>();
}

void PrmPlanner::embedNode(cv::Mat &cspace, vertex node, unsigned int k, bool retry){
  std::vector<TGlobalOrd> neighbours;
  TGlobalOrd nodeOrd = network_[node];

  //Get all nodes in the network ordered by distance to this node
  neighbours = getNeighbours(cspace, node, false);

  int timesConnected(0);
  for(auto const &neighbour: neighbours){
    bool connected = false;

    if(timesConnected == k || !graph_.canConnect(node)){
      //We've reached the max tries or the node has maxed out its connections
      break;
    }

    vertex vNeighbour;
    if(!lookup(neighbour, vNeighbour)){
      //something went wrong adding this neighbour, continue to next
      continue;
    }

    //Attempt to connect to neighbour
    cv::Point pCurrent = lmap_.convertToPoint(reference_, nodeOrd);
    cv::Point pN = lmap_.convertToPoint(reference_, neighbour);
    if(lmap_.canConnect(cspace,pCurrent,pN)){
      connected = graph_.addEdge(node, vNeighbour, distance(nodeOrd, neighbour));
    }

    if(connected){
      //If we successfully connected to a neighbour
      timesConnected++;
    } else if(!retry) {
      //If we are not retrying to find connections, increment count anyway
      timesConnected++;
    }
  }
}

void PrmPlanner::joinNetwork(cv::Mat &cspace, unsigned int k){
  //Attempt to connect each node in the network to its k closest neighbours
  for(auto const &node: network_){
    if(!graph_.canConnect(node.first)){
      continue; //This node has already maxed out its connections
    }

    embedNode(cspace, node.first, k, false);
  }
}

void PrmPlanner::showOverlay(cv::Mat &space, std::vector<TGlobalOrd> path){
  std::vector<cv::Point> pPath = toPointPath(path);

  //Overlay onto map...
  lmap_.overlayPRM(space, composePRM());
  lmap_.overlayPath(space, pPath);
}

std::vector<TGlobalOrd> PrmPlanner::optimisePath(cv::Mat &cspace, std::vector<TGlobalOrd> path){
  std::vector<TGlobalOrd> optPath;

  if(path.size() == 0){
    return optPath; //No path to optimise return empty path
  }

  //Start with the first node
  optPath.push_back(path.at(0));

  //While the goal is not in the optimised path
  while(std::find(optPath.begin(), optPath.end(), path.back()) == optPath.end()){
    TGlobalOrd ordCurr = optPath.back();
    cv::Point pCurrent = lmap_.convertToPoint(reference_, ordCurr);

    //Starting at the end of the path and moving backwards, determine
    //if we can directly connect to the current ordinate
    for(unsigned i = path.size(); i-- > 0;){
      if(path[i] == ordCurr){
        break; //We have reached the current ordinate
      }

      cv::Point pTest = lmap_.convertToPoint(reference_, path[i]);
      if(lmap_.canConnect(cspace, pCurrent, pTest)){
        optPath.push_back(path[i]);
        break; //We have found the earliest node to directly connect to
      }
    }
  }

  return optPath;
}

std::vector<std::pair<cv::Point, cv::Point>> PrmPlanner::composePRM()
{
  std::vector<std::pair<cv::Point, cv::Point>> prm;
  std::map<vertex, edges> nodes = graph_.container();

  //For each vertex in our internal graph, create a pair of points
  //between itself and all its neighbours
  for(auto const &node: nodes){
    cv::Point pCurrent = lmap_.convertToPoint(reference_, network_[node.first]);

    //It has no neighbours, we must still add it to the prm though
    if(node.second.size() == 0){
      prm.push_back(std::make_pair(pCurrent, pCurrent));
    }

    for(auto const &neighbour: node.second){
      cv::Point pNeighbour = lmap_.convertToPoint(reference_, network_[neighbour.first]);

      //Ensure that we are only adding node pairs to the prm that are unique! (no two way connections)
      auto it = std::find_if(prm.begin(), prm.end(),
          [pCurrent, pNeighbour](const std::pair<cv::Point, cv::Point>& element){ return
            element.first == pNeighbour && element.second == pCurrent;});

      if(it == prm.end()){
        prm.push_back(std::make_pair(pCurrent, pNeighbour));
      }
    }
  }

  return prm;
}

std::vector<cv::Point> PrmPlanner::toPointPath(std::vector<TGlobalOrd> path){
  std::vector<cv::Point> pointPath;
  for(auto const &ord: path){
    pointPath.push_back(lmap_.convertToPoint(reference_, ord));
  }

  return pointPath;
}

std::vector<TGlobalOrd> PrmPlanner::toOrdPath(std::vector<vertex> path){
  std::vector<TGlobalOrd> ordPath;

  for(auto const &v: path){
    ordPath.push_back(network_[v]);
  }

  return ordPath;
}

std::vector<TGlobalOrd> PrmPlanner::getNeighbours(cv::Mat &cspace, vertex node, bool shouldConnect){
  std::vector<TGlobalOrd> neighbours;
  TGlobalOrd nodeOrd = network_[node];

  //Attempt to connect each node in network to k closest neighbours
  for(auto const &neighbour: network_){
    if(neighbour.first == node){
      continue; //don't want to connect to ourselves
    }

    //If we care about our ability to connect, then we must check
    if(shouldConnect){
      cv::Point pCurrent = lmap_.convertToPoint(reference_, nodeOrd);
      cv::Point pN = lmap_.convertToPoint(reference_, neighbour.second);

      if(!lmap_.canConnect(cspace, pCurrent, pN)){
        continue; //Will skip this neighbour
      }

      if(!graph_.canConnect(neighbour.first)){
        continue;
      }
    }

    //Add neighbour to list
    neighbours.push_back(neighbour.second);
  }

  //Sort neighbours by distance.
  std::sort(neighbours.begin(), neighbours.end(),[nodeOrd](const TGlobalOrd &lhs, const TGlobalOrd &rhs){
    return distance(lhs, nodeOrd) < distance(rhs, nodeOrd);});

  return neighbours;
}

std::vector<vertex> PrmPlanner::prioritiseNodes(){
  //a list of <vertex, edgeCount>
  std::vector<std::pair<vertex, unsigned int>> nodeConnections;

  for(auto const &entry: network_){
    nodeConnections.push_back(
          std::make_pair(entry.first, graph_.getEdgeCount(entry.first)));
  }

  //Prioritise connection order by nodes who have the least amount of edges
  std::sort(nodeConnections.begin(), nodeConnections.end(),
            [](const std::pair<vertex, unsigned int> &lhs, std::pair<vertex, unsigned int> &rhs){
    return lhs.second < rhs.second;
  });

  //Strip the edge count
  std::vector<vertex> nodes;
  for(auto const &node: nodeConnections){
    nodes.push_back(node.first);
  }

  return nodes;
}

bool PrmPlanner::violatingSpace(TGlobalOrd ord, double r){
  for(auto const &n: network_){
    if(distance(ord, n.second) < 2*r){
      return true;
    }
  }

  return false;
}

vertex PrmPlanner::findOrAdd(TGlobalOrd ordinate){
  vertex v;
  if(existsAsVertex(ordinate)){
    lookup(ordinate, v);
  } else {
    v = addOrdinate(ordinate);
  }

  return v;
}

vertex PrmPlanner::addOrdinate(TGlobalOrd ordinate){
  //Generate a new vertex and add to graph, also adding
  //to the internal lookup table.
  vertex v = nextVertexId();
  graph_.addVertex(v);
  network_.insert(std::make_pair(v, ordinate));

  return v;
}

bool PrmPlanner::existsAsVertex(TGlobalOrd ord){
  for(auto &v: network_){
    if(v.second == ord){
      return true;
    }
  }

  return false;
}

vertex PrmPlanner::nextVertexId(){
  vertex temp = nextVertexId_;
  nextVertexId_++;

  return temp;
}

bool PrmPlanner::lookup(TGlobalOrd ord, vertex &v){
  for(auto &vert: network_){
    if(vert.second == ord){
      v = vert.first;
      return true;
    }
  }

  return false;
}

bool PrmPlanner::ordinateAccessible(cv::Mat &cspace, TGlobalOrd ordinate){
  return existsAsVertex(ordinate) ||
      lmap_.isAccessible(cspace, lmap_.convertToPoint(reference_, ordinate));
}

void PrmPlanner::expandConfigSpace(cv::Mat &space, double robotDiameter){
  lmap_.expandConfigSpace(space, robotDiameter);
}

double PrmPlanner::distance(TGlobalOrd o1, TGlobalOrd o2){
  double a = std::abs(o2.x - o1.x);
  double b = std::abs(o2.y - o1.y);

  return std::sqrt(std::pow(a, 2) + std::pow(b, 2));
}

void PrmPlanner::setReference(const TGlobalOrd reference){
  reference_.x = reference.x;
  reference_.y = reference.y;
}

void PrmPlanner::setMapSize(double mapSize){
  lmap_.setMapSize(mapSize);
}

void PrmPlanner::setResolution(double resolution){
  lmap_.setResolution(resolution);
}

